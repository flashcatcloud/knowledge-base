---
title: "故障静默与抑制"
description: "配置静默与抑制规则，从源头减少无效告警通知"
date: "2024-05-14T10:00:00+08:00"
url: "https://docs.flashcat.cloud/zh/flashduty/channel-settings"
---

在告警管理中，我们经常遇到两种需要“免打扰”的场景：
1.  **已知维护**：比如今晚 22:00 要重启服务器，重启期间的“主机宕机”告警我不想看。—— **这需要“静默”**。
2.  **连锁反应**：比如核心交换机挂了，导致下游 100 台服务器全部失联。我只想收到 1 条交换机故障，不想被 100 条服务器故障轰炸。—— **这需要“抑制”**。

Flashduty 提供强大的静默和抑制机制，帮助您精准控制“什么该报，什么不该报”。

## 视频介绍
---
<Video width="200" style="width: 140px;" src="https://download.flashcat.cloud/flashduty/video/silence.mp4" /></Video>

## 1. 静默规则
---
静默的核心是 **“特定时间 + 特定条件 = 不通知”**。它常用于计划内的变更维护或屏蔽长期无法修复的噪音。

### 配置模式
*   **单次静默**：设置一个起止时间（如 `2024-05-01 22:00` 到 `2024-05-01 23:00`）。过期失效。
    *   *场景：今晚临时升级数据库。*
*   **周期静默**：
    *   **星期模式**：如“每周四 20:00-22:00”。
    *   **日历模式**：引用[服务日历](https://docs.flashcat.cloud/zh/flashduty/calendar-settings)，如“仅法定节假日生效”。
    *   *场景：每天凌晨 02:00 进行大数据备份，会导致磁盘 IO 飙升，需要周期性屏蔽。*

### 快速静默
这是最常用的功能。当您在手机或 Web 端收到一条告警，确认它是已知问题（比如正在发布的变更），可以直接在故障详情页点击 **更多操作 => 快速静默**。
*   系统会自动提取当前故障的标签作为静默条件。
*   默认静默 24 小时（可调）。

![2025-12-09-16-58-03](https://docs-cdn.flashcat.cloud/images/png/e80c2632d9065b28499edfa5a81a8505.png)

### 静默行为
*   **直接丢弃**：告警完全不记录，既不会出现在告警列表，也不会生成故障。
*   **保留标记（推荐）**：告警依然会入库并展示在 **告警列表** 中，标记为“已静默”，但**不会生成故障**（或不会触发故障通知），确保无打扰。

## 2. 抑制规则
---
抑制的核心是 **“如果 A 发生了，就别报 B”**。它利用故障之间的依赖关系或等级关系，消除冗余噪音。

### 核心逻辑
抑制规则由三个要素组成：
1.  **源故障**：作为“抑制器”的故障（如 Critical 级别的故障）。只有当源故障处于**活跃状态**（未关闭）时，抑制规则才会生效。
2.  **目标故障**：被抑制的故障（如 Warning 级别的故障）。
3.  **关联条件**：源和目标必须满足什么关系（如 `host` 相同）。

### 典型应用场景

#### 场景一：等级抑制（告警升级）
**需求**：同一台主机，如果已经报了 **Critical** (CPU > 90%)，就没必要再报 **Warning** (CPU > 80%) 了。
*   **配置**：
    *   **源故障**：等级 = Critical
    *   **目标故障**：等级 = Warning
    *   **关联条件**：`host` 标签相同，`check` 标签相同。
*   **效果**：当 CPU 飙升直接触发 Critical 时，随后产生的 Warning 告警会被自动抑制；如果先产生 Warning 后升级为 Critical，新的 Critical 通知会发出，旧的 Warning 可能会被自动解决（取决于聚合策略）。

#### 场景二：拓扑抑制（根因屏蔽）
**需求**：当 `db-master` 数据库宕机时，所有依赖它的应用服务（Order-Service, User-Service）都会报“连接超时”。我们希望只收到数据库的报警。
*   **前提**：您的应用告警中需要带有依赖标签，例如 `dependency: db-master`。
*   **配置**：
    *   **源故障**：`service = db-master`
    *   **目标故障**：`dependency = db-master`
    *   **关联条件**：`cluster` 标签相同（确保只抑制同一集群内的关联故障，避免误杀）。
*   **效果**：数据库一挂，下游数十个服务的连接报错全部被拦截。

### 配置示例
下图展示了一个“等级抑制”的配置：当存在相同 `check`（检查项）的 Critical 故障时，抑制 Warning 和 Info 级别的故障。

![2025-12-09-16-35-56](https://docs-cdn.flashcat.cloud/images/png/5ecf02ac6152866a32057ec7fc806b9b.png)

:::caution 时序依赖
抑制仅对 **后续发生** 的故障生效。这意味着，如果目标故障先于源故障发生，或者两者同时到达但目标故障先被系统处理，它将不会被抑制。
因此，抑制主要用于处理因果关系明确、且源故障通常先被检测到的场景（如网络中断导致主机失联）。
:::

## 对比总结
---

| 特性 | 静默| 抑制|
| :--- | :--- | :--- |
| **触发机制** | 基于时间 + 条件匹配 | 基于已存在的“源故障” |
| **典型用途** | 维护窗口、屏蔽已知噪音 | 根因失效导致的大面积衍生告警 |
| **依赖关系** | 无 | 强依赖（需要先有一个活跃的源故障） |
| **配置难度** | 低 | 中（需要梳理依赖或标签关系） |

## 常见问题
---

<details>
  <summary>配置了静默规则，为什么告警还在列表里显示？</summary>
  请检查静默行为是否配置为“保留标记”。在此模式下，被静默的告警依然会记录在 **告警列表** 中（带有静默图标），以便事后审计和追溯。但请放心，这些告警不会生成活跃故障，也不会发送通知。
</details>

<details>
  <summary>抑制规则为什么没生效？</summary>
  可能有以下原因：
  1. **时序问题**：被抑制的故障（目标故障）比源故障先发生，或者几乎同时发生但先被处理。
  2. **源故障已恢复**：源故障（如 Critical 告警）如果已经关闭，抑制作用立即失效。
  3. **条件不匹配**：请仔细检查“关联条件”（如 `host` 是否完全一致）。
</details>

<details>
  <summary>静默规则过期后，之前的告警会重新通知吗？</summary>
  不会。静默规则仅在告警触发的那一刻生效。一旦告警被标记为“静默”，即使规则随后过期，该条历史告警也不会“死灰复燃”补发通知。只有新触发的告警才会恢复正常通知。
</details>
