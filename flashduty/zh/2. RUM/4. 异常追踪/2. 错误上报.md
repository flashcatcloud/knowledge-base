# FlashCat RUM 错误监控

## 概述

FlashCat RUM（Real User Monitoring）提供强大的前端错误监控功能，自动捕获浏览器中的未处理错误，并支持手动上报自定义错误。通过详细的错误数据和上下文信息，您可以快速定位问题根因，优化用户体验。本文档介绍错误捕获机制、手动上报方法、React 集成以及错误数据结构。

## 上报方式

### 自动错误捕获

FlashCat RUM SDK 自动捕获以下类型的浏览器错误：

- **未捕获的异常**: 运行时抛出的 JavaScript 异常（如 `TypeError`、`ReferenceError`）。
- **未处理的 Promise 拒绝**: 未被 `.catch()` 处理的 Promise 错误。
- **网络错误**: XHR 或 Fetch 请求失败（如 4xx、5xx 状态码或网络中断）。
- **React 渲染错误**: React 组件渲染期间的异常（需配合错误边界）。

**注意**:

- 自动捕获的错误默认包含堆栈跟踪、错误消息和来源信息。
- 来自浏览器扩展或第三方脚本的错误（如 `network` 来源）会被过滤，避免数据污染。

### 手动错误上报

通过 `addError` API，您可以手动上报已处理的异常、自定义错误或其他未被自动捕获的错误。手动上报适合以下场景：

- 记录业务逻辑中的已处理错误。
- 附加上下文信息（如用户 ID、页面状态）以便问题排查。
- 监控第三方服务或异步操作的异常。

#### 示例：上报自定义错误

```javascript
// 上报带有上下文的自定义错误
const error = new Error("登录失败");
window.DD_RUM.addError(error, {
  pageStatus: "beta",
  userId: "12345",
  action: "login_attempt",
});
```

#### 示例：上报网络错误

```javascript
fetch("https://api.example.com/data").catch((error) => {
  window.DD_RUM.addError(error, {
    requestUrl: "https://api.example.com/data",
    method: "GET",
  });
});
```

#### 示例：上报已处理异常

```javascript
try {
  // 可能抛出异常的业务逻辑
  riskyOperation();
} catch (error) {
  window.DD_RUM.addError(error, {
    operation: "riskyOperation",
    timestamp: Date.now(),
  });
}
```

### React 错误边界集成

FlashCat RUM 支持通过 React 错误边界捕获组件渲染错误，并将错误信息上报。您可以在 `componentDidCatch` 中调用 `addError` API，附加组件堆栈信息以便调试。

#### 示例：React 错误边界

```javascript
class ErrorBoundary extends React.Component {
  componentDidCatch(error, info) {
    const renderingError = new Error(error.message);
    renderingError.name = "ReactRenderingError";
    renderingError.stack = info.componentStack; // 组件堆栈
    renderingError.cause = error; // 原始错误

    window.DD_RUM.addError(renderingError, {
      component: this.props.componentName || "Unknown",
      version: "1.0.0",
    });
  }

  render() {
    return this.props.children;
  }
}
```

#### 使用方式

```javascript
<ErrorBoundary componentName="UserProfile">
  <UserProfile />
</ErrorBoundary>
```

### 错误数据结构

每条错误数据包含以下属性，用于描述错误详情和上下文：

| 属性            | 类型   | 描述                                                                |
| --------------- | ------ | ------------------------------------------------------------------- |
| `error.source`  | string | 错误来源（如 `console`、`network`、`custom`、`source`、`report`）。 |
| `error.type`    | string | 错误类型或错误码（如 `TypeError`、`NetworkError`）。                |
| `error.message` | string | 简洁的人类可读错误消息。                                            |
| `error.stack`   | string | 错误堆栈跟踪或补充信息。                                            |
| `error.causes`  | Array  | 提供额外上下文的关联错误列表（可选）。                              |
| `context`       | Object | 自定义上下文信息（如页面状态、用户 ID），通过 `addError` 传入。     |

### 错误过滤与配置

为确保错误数据的准确性和相关性，FlashCat RUM 应用以下过滤规则：

- **默认过滤**:
  - 仅处理 `source` 为 `custom`、`source`、`report` 或 `console` 的错误。
  - 忽略来自浏览器扩展、第三方脚本或 `network` 来源的无关错误。
- **堆栈要求**: 错误必须包含堆栈跟踪信息，否则可能被忽略。
- **自定义过滤**:
  - 使用 `beforeSend` 回调自定义错误处理逻辑，过滤或修改错误数据。

#### 示例：自定义错误过滤

```javascript
window.DD_RUM.init({
  beforeSend: (event) => {
    if (event.type === "error") {
      // 忽略特定错误消息
      if (event.error.message.includes("ThirdPartyScript")) {
        return false; // 丢弃该错误
      }
      // 添加全局上下文
      event.context = { ...event.context, appVersion: "2.1.0" };
    }
    return true;
  },
});
```

## 错误聚合

### 异常聚合的工作原理

FlashCat 异常聚合会将具有相同根本原因的错误事件分组为一个问题。聚合基于以下因素：

- **错误消息**：相同或相似的错误消息会被视为同一问题。
- **堆栈跟踪**：堆栈帧的相似性（包括文件名、函数名、行号和列号）是分组的关键依据。
- **上下文信息**：如浏览器类型、用户位置、应用版本等元数据可能影响分组。
- **自定义指纹**：开发者可以通过自定义规则进一步控制分组逻辑。

当新错误发生时，FlashCat 会与现有问题进行匹配：

- 如果错误消息相同，或堆栈顶部帧及后续 3 个中的 4 个帧匹配，则归入现有问题。
- 如果不匹配，则创建新的问题组。

### 配置异常聚合

#### 自动聚合

FlashCat 默认启用异常聚合，无需额外配置即可开始工作。Browser SDK 会自动收集错误数据并进行分组。以下是 Web 环境下的基本设置：

1. **集成 FlashCat Browser SDK**

   在 HTML 文件中引入 FlashCat Browser SDK：

   ```html
   <script src="https://cdn.flashcat.com/rum-browser-sdk.js"></script>
   ```

2. **初始化 SDK**

   初始化 SDK 时，指定应用 ID 和环境：

   ```javascript
   window.FLASHCAT_RUM.init({
     applicationId: "rum-application-id",
     environment: "production",
     version: "1.0.0",
   });
   ```

#### 自定义分组

若默认分组无法满足需求，可以通过自定义指纹实现更精细的控制。以下是 Web 环境下的配置方法：

1. **手动添加自定义指纹**

   在手动报告错误时，通过 `addError` 添加自定义指纹：

   ```javascript
   window.FLASHCAT_RUM.addError(new Error("My error message"), {
     source: "custom",
     fingerprint: "my-custom-grouping-fingerprint",
   });
   ```

2. **使用 beforeSend 回调**

   通过 `beforeSend` 回调动态设置指纹：

   ```javascript
   window.FLASHCAT_RUM.init({
     applicationId: "rum-application-id",
     environment: "production",
     beforeSend: (event) => {
       if (event.type === "error") {
         event.error.fingerprint = "my-custom-grouping-fingerprint";
       }
       return true;
     },
   });
   ```

   **注意**：

   - 自定义指纹必须为字符串类型。
   - `beforeSend` 回调还可用于过滤无关错误（如第三方脚本错误）。

#### Web 特定注意事项

- **SourceMap 集成**：

  - 上传 `sourcemap` 文件以解码压缩后的堆栈跟踪，确保聚合后的错误堆栈可映射到原始源代码。
  - 示例：使用 `flashcat-cli` 上传 `sourcemap`：
    ```bash
    flashcat-cli sourcemaps upload --service my-service --release-version 1.0.0 --minified-path-prefix /assets --api-key your-api-key ./dist
    ```

- **第三方脚本错误**：
  - 默认情况下，FlashCat 会过滤来自浏览器扩展或第三方脚本的错误（如 `network` 来源），以减少噪声。
  - 可通过 `beforeSend` 进一步自定义过滤规则：
    ```javascript
    beforeSend: (event) => {
      if (
        event.error.source === "network" &&
        event.error.message.includes("ThirdPartyScript")
      ) {
        return false; // 丢弃该错误
      }
      return true;
    };
    ```

### 查看和分析聚合结果

1. **异常追踪页面**

   在 FlashCat 平台，导航至 **数字体验 > 异常追踪**，查看聚合后的问题列表。每个问题包含：

   - 错误消息和堆栈跟踪（若上传了 `sourcemap`，会显示原始源代码位置）。
   - 用户会话时间线。
   - 元数据（如浏览器类型、版本号）。

2. **过滤和分组**

   使用查询功能按 `@error.message`、`@error.type` 或自定义属性过滤问题。支持按环境、版本等属性分组。

   示例查询：

   ```plaintext
   @error.message:"My error message" @source:custom
   ```

3. **监控设置**

   创建监控以实时跟踪问题：

   - **新问题监控**：检测 `For Review` 状态下的新问题。
   - **高影响监控**：关注 `For Review` 或 `Reviewed` 状态下影响较大的问题。

   示例查询：

   ```plaintext
   error-tracking("@error.message:My error message").source("web").new().last("1d") > 0
   ```

## 常见问题与最佳实践

### 常见问题

1. **为什么某些错误未被聚合？**

   - 确认堆栈跟踪是否完整，或自定义指纹是否冲突。
   - 检查 `sourcemap` 是否正确上传，若未上传，堆栈可能无法正确解析。

2. **如何减少第三方脚本错误噪音？**

   - 使用 `beforeSend` 回调过滤特定错误来源或消息。
   - 示例：
     ```javascript
     beforeSend: (event) => {
       if (event.error.source === "network") return false;
       return true;
     };
     ```

3. **自定义分组无效怎么办？**

   - 确保 `fingerprint` 属性正确设置，且值为字符串。
   - 检查 `beforeSend` 回调是否被正确调用。

### 最佳实践

1. **丰富上下文信息**:

   - 在 `addError` 中附加业务相关上下文（如用户 ID、操作类型），便于问题定位。
   - 示例：`{ userId: "12345", action: "submit_form" }`。

2. **优化错误边界**:

   - 为关键 React 组件配置错误边界，确保渲染错误被捕获。
   - 记录组件名称和版本，便于追踪问题。

3. **控制错误量**:

   - 使用采样率或 `beforeSend` 过滤低价值错误，避免数据过载。
   - 优先监控影响用户体验的关键错误。

4. **分析与可视化**:

   - 在 RUM Explorer 中使用 `@error.message` 或 `@error.type` 查询错误。
   - 构建仪表板，监控错误趋势和分布。

## 下一步

- \[查看错误分析仪表板\](./4. 错误分析看板.md)
- \[优化错误监控配置\](../4. 最佳实践/4. 错误监控.md)
